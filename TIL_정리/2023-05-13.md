# 2023-05-13

## 키워드
- abstract class
  - 클래스들의 공통적인 특성을 추출해서 선언한 클래스
- 추상 클래스를 왜 사용하는 것일까?
  - 공통된 필드와 메소드 이름을 통일할 목적을 가진다
- 추상 클래스 선언
  - abstract 키워드
- 추상 메소드와 오버라이딩
  - 추상 메소드 : 메소드 선언부만 있고, 실행 내용이 없는 메소드
  - 추상 메소드를 왜 사용하는지? : 하위 실체 클래스가 반드시 실행 내용을 채우도록 강요하고자 하는 경우, 메소드 시그니처만 통일하고, 실행 내용은 실체 클래스마다 달라야 하는 경우
  - 자식 클래스 (실체 클래스) 에서 추상 메소드를 오버라이딩하지 않으면, 컴파일 에러 발생
- interface : 객체의 사용 방법을 정의한 타입
   - interface의 default 메소드 용도 : 기존 인터페이스를 확장해서 새로운 기능을 추가하기 위해서
- Hash
  - Hash Function
  - Hash Table
- Hash Collision
  - Separate Chaining
  - Open Addressing
    - Linear Probing
    - Quadratic Probing
    - Double Hashing Probing

---

## Abstract Class (추상 클래스)
- 클래스들의 공통적인 특성을 추출해서 선언한 클래스
- 실체 클래스와는 상속의 관계를 가진다 (실체 클래스는 추상 클래스의 모든 특성을 물려받고, 추가적인 특성을 가질 수 있다)
- 추상 클래스는 객체를 직접 생성해서 사용할 수 없다 (new 연산자를 이용해서 인스턴스 생성 불가능)

### 추상 클래스를 왜 사용하는 것일까?
1. 실체 클래스들의 공통된 필드와 메소드의 이름을 통일할 목적 
   - 실체 클래스마다 필드랑 메소드가 서로 달라지면 유지보수 측면에서 좋지 않다
     - ex) 소유자의 이름을 저장하는 필드를 `Telephone` 클래스에서는 `owner` 라고 하고, `SmartPhone` 클래스에서는 `user` 라고 설계한다고 가정해보면, 동일한 의미를 가지는 필드임에도 불구하고 중구난방임을 확인할 수 있다
     - 이러한 경우, `Phone` 이라는 추상 클래스를 선언하고, 소유자인 `owner` 필드, 메소드를 선언하고 각 실체 클래스는 추상 클래스를 상속하게 되면 필드 및 메소드 명을 통일할 수 있다
2. 실체 클래스를 작성할 때 시간을 절약할 수 있음
   - 공통적인 필드와 메소드는 추상 클래스에 선언해두고, 실체 클래스마다 다른 부분만 실체 클래스에 선언하면 클래스 작성 시간을 줄일 수 있다

## 추상 클래스 선언
- `abstract` 키워드
```java
public abstract class 클래스명 {
    // 필드

    // 생성자

    // 메소드
}
```
- abstract를 붙이면 new 연산자를 이용해서 **객체를 만들지 못한다**
- new 연산자로 직접 생성자를 호출할 수는 없는데, 자식 객체가 생성될 때, `super()` 를 호출해서 추상 클래스를 생성하니까 추상 클래스도 생성자가 필수!

## 추상 메소드와 오버라이딩
- 추상 메소드
  - 


## Interface (인터페이스)
- 객체의 사용 방법을 정의한 타입

### 인터페이스를 왜 사용할까?
- 개발 코드를 수정하지 않고, 사용하는 객체를 변경할 수 있도록 하기 위해

### 인터페이스 선언
- `interface` 키워드
```java
[public] interface 인터페이스명 { 
  // 상수

  // 추상 메소드

  // default 메소드

  // static 메소드
}
```

### 왜 Interface 에서 default Method를 쓸 수 있게 된 것일까?
- 기존 인터페이스를 확장해서 새로운 기능을 추가하기 위해서 default 메소드를 인터페이스에서 허용했다

#### Interface에서 default 메소드가 필요한 예시
- 기존 `MyInterface` 라는 인터페이스, 이를 구현한 클래스 `MyClassA` 가 있었는데, `MyInterface`에 기능을 추가해야 하는 상황 발생
- `MyInterface` 에 기능을 추가하려고 추상메소드를 추가하면 `MyClassA` 에서 추상 메소드를 구현한 실체 메소드가 없으니까 컴파일 에러가 발생한다
- 이런 경우, default 메소드를 이용하게 되면, 기존 인터페이스를 확장해서 새로운 기능을 추가할 수 있게된다

#### default 메소드가 있는 인터페이스의 상속
- default 메소드를 단순히 상속받는다
- default 메소드를 오버라이딩하여 실행 내용을 변경한다
- default 메소드를 추상 메소드로 재선언한다 --> 이를 구현하는 클래스는 추상메소드로 재선언된 메소드의 실체 메소드를 무조건 가지고 있어야 한다

## Hash
- Hashing 자체는 해시 함수를 이용하여 해시 테이블 안에 **key, value 쌍**을 저장하는 방식을 말한다
-  만약, 해시 함수 `H(x)`가 있다고 가정해보자. `H(x)` 는 input 값  `x` 를 `x % 10` 의 값으로 매핑해주는 함수이다

### Hash 장점
- hash는 내부적으로 **배열**을 사용하여 데이터를 저장하기 때문에 빠른 검색 속도를 갖는다. 특정한 값을 탐색하는데 데이터 고유의 인덱스로 접근하게 되므로 시간복잡도가 `O(1)`이 된다
- 하지만 문제는 이 인덱스로 저장되는 key값이 불규칙하다는 것이다
- 그래서 **특별한 알고리즘**을 이용하여 저장할 데이터와 연관된 고유한 숫자를 만들어 낸 뒤 이를 인덱스로 사용한다
- 특정 데이터가 저장되는 인덱스는 그 데이터만의 고유한 위치이기 때문에, 삽입 연산 시 다른 데이터의 사이에 끼어들거나, 삭제 시 다른 데이터로 채울 필요가 없으므로 연산에서 추가적인 비용이 없도록 만들어진 구조이다

### Hash Function
- 해시에서는 '특별한 알고리즘'을 통해 고유한 인덱스 값을 설정하는 것이 가장 중요한데, 여기서의 **특별한 알고리즘**을 hash method 또는 **해시 함수(hash function)**라고 한다. 이 메소드에 의해 반환된 데이터의 고유 숫자 값을 **hashcode**라고 한다
- 저장되는 값들의 key 값을 hash function을 통해서 작은 범위의 값들로 바꿔준다 (키를 해시로 바꾸어주는 역할을 한다)

## Hash Table
- 해시 테이블이란 빠른 삽입 연산 및 검색을 지원하기 위해 해시 함수를 이용하여 (Key, Value) 형태로 데이터를 저장하는 자료구조이다
- 내부적으로 배열 (버킷)을 사용해서 데이터를 저장해서 빠른 검색 속도를 제공한다
- 각 Key에 해시함수를 적용해서 배열의 고유한 인덱스를 생성하고, 이 인덱스를 활용해서 값을 저장하거나 검색한다
  - 실제 값이 저장되는 장소 : 버킷 or 슬롯

### 해시테이블로 어떻게 빠른 검색을 할 수 있다는 것일까? 
- 자료구조의 관점에서 테이블이란, 표에 저장되는 데이터가 (key, value) 쌍을 이룰때 테이블에 데이터가 저장된다고 한다
- 이렇게 테이블에 저장되는 모든 데이터들은 이를 구분할 수 있는 **key**가 있어야 하고, 이 키는 데이터를 **구분하는 기준**이 되기 때문에 중복이 되어서는 안된다는 조건을 가진다
- 이런 구조로 데이터를 저장하면 Key 값으로 데이터를 찾을 때, 해시 함수를 한 번만 수행하면 되니까 데이터를 빠르게 저장 / 삭제 / 조회할 수 있다!! => 평균 시간 복잡도 : `O(1)`

### HashTable의 원리
- 해시 함수를 이용하여 **key를 저장 공간에 매핑하는 것**이 가장 중요하다

1. 새로운 키 저장 시, 해시 함수는 해당 키가 저장 공간 내 어느 위치에 저장되어야 할지를 결정
2. 키를 검색하고자 할 때, 해시 테이블이 키 저장 시에 이용했던 같은 해시 함수를 이용하여 데이터 검색


### Hash Collision
그런데, 어설픈 hash function을 통해서 key 값들을 결정한다면 계속적으로 동일한 값이 도출될 수가 있다
- 이렇게 되면 동일한 key 값에 복수 개의 데이터가 하나의 테이블에 존재할 수 있게 되어 버린다
- 이를 **Collision** 이라고 한다
- Collision : 서로 다른 두 개의 키가 같은 인덱스로 hashing(hash 함수를 통해 계산됨을 의미)되면 같은 곳에 저장할 수 없게 된다
- 📌 그래서, Hash Function은 해시 충돌을 일으킬 확률을 최대한 줄이는 함수를 만들어내는 것이 관건이다!!!!!!

### Hash 충돌 해결 방식
#### 1. Separate Chaining (분리 연결법)

- 충돌이 발생했을 때, 동일한 버킷에 저장하는데, 이를 연결 리스트 형태로 저장하는 방식
- Java8의 `HashTable` 은 `Self-Balancing Binary Search Tree` 자료구조를 사용해서 Chaining 방식을 구현하였다

![Separate Chaining](/images/Chaining.png)

#### Separate Chaining의 장점
- 해시 테이블 확장 안해도 되고, 간단하게 구현할 수 있고 손쉽게 데이터를 삭제할 수 있다

#### 단점
- 데이터의 수가 많아지면 동일한 버킷에 chaining 되는 데이터가 많아져서 이렇게 되면 캐시 효율성이 감소한다


#### 2. Open Addressing (개방 주소법)
- 비어있는 해시테이블의 공간을 활용하는 방법으로, 3가지 방식이 존재한다
  - 1. Linear Probing
  - 2. Quadratic Probing
  - 3. Double Hashing Probing


#### 2-1. Linear Probing
- 지금 버킷 인덱스로부터 고정폭만큼씩 이동해서 차례대로 검색한 다음에, 비어있는 버킷에 충돌난 데이터를 저장하는 방식

![Linear Probing](/images/LinearProbing.png)

#### 2-2. Quadratic Probing
- 해시의 저장 순서 폭을 제곱으로 저장하는 방식
- 처음 충돌 발생 —> 1만큼 이동하고, 그 다음 충돌 발생 —> 2^2 —> 그 다음 충돌 발생 —> 3^3

![Quadratic Probing](/images/QuadraticProbing.png)

#### 2-3. Double Hashing Probing
- 해시된 값을 한 번 더 해싱해서 해시 규칙성을 없애버리는 방식
- 해시된 값을 한 번 더 해싱해서 새로운 주소를 할당하므로 다른 방법들보다 더 많은 연산이 필요하다 !!!
