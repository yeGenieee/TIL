# 2023-06-03

### 📌 학습 계획
- 제네릭
  - 왜 사용하는지
  - 주요 개념
  - 바운디드 타입
  - 와일드 카드


### ✏️ TIL
- 제네릭
  - 왜 사용하는지
  - 주요 개념
  - 바운디드 타입
  - 와일드 카드

## 제네릭이란
- Java 5부터 새로 추가된 개념이다

## 제네릭을 왜 사용할까?
- 제네릭 타입을 이용함으로써 잘못된 타입이 사용될 수 있는 문제를 컴파일 과정에서 제거할 수 있게 하려고 사용한다
- 제네릭은 클래스와 인터페이스, 메소드를 정의할 때 타입 (type)을 파라미터(parameter)로 사용할 수 있도록 하는데, 
- 타입 파라미터는 코드 작성 시 구체적인 타입으로 대체되어 다양한 코드를 생성하도록 해준다
- 그래서, 제네릭을 사용하는 코드는 비제네릭 코드에 비해 아래와 같은 이점을 가진다

### 장점
#### 1. 컴파일 시 강한 타입 체크를 할 수 있다.
- 자바 컴파일러는 코드에서 잘못 사용된 타입 때문에 발생하는 문제점을 제거하기 위해 제네릭 코드에 대해 강한 타입 체크를 한다
- Runtime 에러가 발생하는 것 보다는 컴파일 시에 에러를 판별하여 사전에 방지하는 것이 좋으므로 제네릭을 사용하면 컴파일 타임에 에러를 판별할 수 있다

#### 2. 타입 변환 (casting) 을 제거한다.
- 비제네릭 코드는 불필요한 타입 변환을 하므로, 프로그램 성능에 악영향을 미친다.
##### 예시
- 비제네릭 코드
```java
List list = new ArrayList();
list.add("hello");
String str = (String) list.get(0);
```
- item을 얻어올 때 반드시 String으로 **타입 변환 필요** 하다

- 제네릭 코드
```java
List<String> list = new ArrayList<String>();
list.add("hello");
String str = list.get(0);
```
- List에 저장되는 요소를 String 타입으로 국한하기 때문에 item을 찾아올 때 **타입 변환을 할 필요가 없어서** 프로그램 **성능이 향상** 된다


## 제네릭 사용법
### 제네릭 타입
- 타입을 파라미터로 가지는 클래스와 인터페이스
- 클래스 또는 인터페이스 이름 뒤에 `<>` 부호가 붙고, 사이에 타입 파라미터가 위치한다

```java
public class 클래스명<T> { ... }
public interface 인터페이스명<T> { ... }
```
- 타입 파라미터는 일반적으로 대문자 알파벳 한 글자로 표현한다
- 제네릭 타입을 실제 코드에서 사용하려면 타입 파라미터에 구체적인 타입을 지정해야 한다

### 타입 파라미터를 사용하는 이유
```java
public class Box {
    private Object object;
    public void set(Object object) {
        this.object = object;
    }
    public Object get() {
        return object;
    }
}
```
- 위의 Box 클래스에서는 필드 타입이 `Object` 타입이다
  - 필드에 모든 종류의 객체를 저장하고 싶어서 `Object` 타입으로 선언한다
  - 모든 자바 객체는 `Object` 타입으로 자동 타입 변환되어 저장된다

```java
Object object = 자바의 모든 객체;
```
- `set()` 메소드에서 매개 변수 타입으로 `Object` 를 사용함으로써 매개값으로 자바의 모든 객체를 받을 수 있다
- `get()` 메소드는 `Object` 필드에 저장된 객체를 `Object` 타입으로 리턴한다
  - 만약 필드에 저장된 원래 타입의 객체를 얻으려면 **강제 타입 변환 필요**하다

```java
Box box = new Box();
box.set("hello"); // String 타입을 Object 타입으로 자동 타입 변환해서 저장
String str = (String) box.get(); // Object 타입을 String 타입으로 강제 타입 변환해서 얻는다
```

##### Object 타입을 사용하면
- 모든 종류의 자바 객체를 저장할 수 있다
##### 그러나 (단점)
- 빈번한 타입 변환으로 프로그램 성능이 저하될 수 있다
  - 저장할 때 타입 변환이 발생하기 때문이다
  - 읽어올 때도 타입 변환이 발생하기 때문이다

### 모든 종류의 객체를 저장하면서 타입 변환이 발생하지 않도록 하는 제네릭

#### 제네릭으로 수정된 Box 클래스
```java
public class Box<T> {
    private T t;
    public void set(T t) {
        this.t = t;
    }
    public T get() {
        return t;
    }
}
```
- 타입 파라미터 `T` 를 사용해서 `Object`  를 대체한다
- `T` 는 Box 클래스로 객체를 사용할 때 구체적인 타입으로 변경된다
```java
Box<String> box = new Box<String>();
```

- 타입 파라미터 `T` 는 `String` 타입으로 변경되어 `Box` 클래스의 내부가 자동으로 재구성된다
```java
public class Box<String> {
    private String t;
    public void set(String t) {
        this.t = t;
    }
    public String get() {
        return t;
    }
}
```
- 이렇게 되면, set() 과 get() 메소드를 이용할 때 전혀 타입 변환이 발생하지 않는다
- 제네릭은 클래스 설계 시 구체적인 타입을 명시하지 않고, 타입 파라미터로 대체했다가 실제 클래스가 사용될 때 구체적인 타입을 지정함으로써 타입 변환을 최소화 시킨다


## 제네릭 주요 개념 (바운디드 타입, 와일드 카드)

### 와일드 카드 타입 (<?>, <? extends ...>, <? super ...>)

- 제네릭 타입을 매개값이나 리턴 타입으로 사용할 때 구체적인 타입 대신에 와일드 카드(?)를 사용할 수 있다

#### 제네릭타입 <?> : Unbounded Wildcards (제한 없음)

- 타입 파라미터를 대치하는 구체적인 타입으로 모든 클래스나 인터페이스 타입이 올 수 있다

#### 제네릭타입 <? extends 상위타입> : Upper Bounded Wildcards (상위 클래스 제한)

- 타입 파라미터를 대치하는 구체적인 타입으로 상위 타입이나 하위 타입만 올 수 있다

#### 제네릭타입 <? super 하위타입> : Lower Bounded Wildcards (하위 클래스 제한)

- 타입 파라미터를 대치하는 구체적인 타입으로 하위 타입이나 상위 타입이 올 수 있다


## Reference
- 신용권, 『이것이 자바다』, 한빛미디어(2015), p.654 ~ p.671
- 이상민, 『자바의 신』, 로드북(2018), p.572~ p.583
