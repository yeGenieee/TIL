# 2023-05-29

### 📌 학습 계획
- JVM 내 실행 엔진
  - Interpreter
  - JIT Compiler
- 꼬리물기 질문 스터디 진행 및 내용 정리

### ✏️ TIL
- JVM 내 Execution Engine
  - Interpreter
  - JIT Compiler
- 꼬리물기 질문 스터디 (2023-05-29 7차)
  - `==`, `equals`, `hashcode`
  - HashTable, HashMap
  - Interface vs Abstract Class
  - Final
  - Enum
  - Rehashing
  - Marker Interface


## JVM의 Execution Engine
- 클래스 로더를 통해서 JVM 내의 런타임 데이터 영역에 배치된 바이트 코드를 한 줄 씩 실행하는 역할을 한다
- 자바 바이트 코드를 명령어 단위로 읽어서 실행한다
- 그런데, 자바 바이트 코드는 기계가 바로 수행할 수 있는 언어 형태가 아닌 중간 코드 형태여서
  - 실행 엔진은 바이트 코드를 실제로 JVM 내부에서 기계가 실행할 수 있는 형태로 변경한다

### 실행 엔진이 JVM 내부에서 기계가 실행할 수 있는 형태로 변경하는 방식 2가지
1. 인터프리터 (Interpreter)
2. JIT 컴파일러 (Just-In-Time Compiler) 

> 컴퓨터 프로그램을 실행하는 방식 2가지
> 1. 인터프리트 방식
>     - 프로그램을 실행할 때 마다 컴퓨터가 알아 들을 수 있는 언어로 변환하는 작업을 수행하는 방식
>     - 간편하지만 성능이 매우 느리다
> 2. 정적 컴파일 방식
>     - 실행하기 전 컴퓨터가 알아 들을 수 있는 언어로 미리 변환한다 (변환 작업은 딱 한번만 수행한다)

## Interpreter
-  바이트코드 명령어를 하나씩 읽어서 해석하고 실횅한다
-  하나씩 해석하고 실행하므로 바이트 코드 하나하나의 해석은 빠른데, 인터프리팅 결과의 실행 자체는 느리다

## JIT Compiler (Just-In-Time Compiler)
- 인터프리터의 단점을 보완하기 위해 도입된 사항이다
  - 왜?
    - 인터프리터의 단점이 결국 하나씩 해석하고 실행하므로 인터프리팅 결과의 실행 자체가 느리다는 점
    - 인터프리터는 하나의 메서드가 여러번 호출될 때 마다 인터프리터를 작동해야 한다
- 인터프리터 방식으로 실행하다가 적절한 시점에 바이트코드 전체를 컴파일해서 네이티브 코드로 변경하고, 
- 그 이후에는 해당 메서드를 더 이상 인터프리팅하지 않고 네이티브 코드로 직접 실행하는 방식이다

### JIT 컴파일러 도입의 장점
- JIT를 사용하면 반복적으로 수행되는 코드를 네이티브 코드로 변경해서 직접 실행하면 매우 빠른 성능을 보인다
- 그리고, 네이티브 코드는 캐시에 담아두었다가 재사용하므로 한 번 JIT 컴파일러를 통해 변환된 코드는 계속 빠르게 사용할 수 있다

### JIT 컴파일러의 단점
- JIT 컴파일러가 컴파일하는 과정은 바이트코드를 하나씩 인터프리팅하는 것보다 훨씬 오래 걸린다
- 그래서, 만약에 한 번만 실행되는 코드라고 하면, 컴파일하지 않고 인터프리팅하는 것이 훨씬 유리하다
- JIT 컴파일러를 사용하는 JVM들은 내부적으로 해당 메서드가 얼마나 자주 수행되는지 체크하고, 일정 정도를 넘을 때에만 컴파일을 수행한다

## JIT 컴파일러의 동작 방식
1. 바이트코드를 중간 단계의 표현인 IR (Intermediate Representation) 으로 변환하여 최적화를 수행하고 그 다음 네이티브 코드를 수행한다

## 꼬리물기 질문 스터디
### `==`, `equals`, `hashcode`
- `==` : 동일성 비교 연산자
- `equals` : 동등성 비교 연산자
- `hashcode` : 동등성 비교 연산자

### HashTable이 존재하는 이유와 HashMap의 차이점
- HashTable은 존재 목적이 오직 하위 호환성에 있다
- HashTable은 Thread-safe하다
  - 모든 data 변경 메서드에 `synchronized` 로 선언되어 있어서 멀티 쓰레드 환경에서 data의 무결성을 보장해준다
- HashMap은 Thread-safe하지 않다
  - 멀티 쓰레드 환경에서 동시에 객체의 data를 조작하는 경우 data가 깨질 수 있다

### 인터페이스와 추상클래스의 차이
- 스스로 인스턴스화를 할 수 있는지
- 다중 상속을 허용하는지
- 사용 목적의 차이
  - 추상 클래스 : 상속에 초점을 맞춤
  - 인터페이스 : 다형성에 초점을 맞춤

### final 키워드
- 클래스에 final : 더 이상 상속을 할 수 없는 클래스
- 메소드에 final : 더 이상 오버라이딩을 할 수 없는 메소드
- 변수에 final 
  - Primitive Type : 값을 변경할 수 없음
  - Reference Type : 참조 주소 값을 변경할 수 없음

### Enum
- 열거형 (연속된 값이나 특정 범주 내의 값을 나타내고자 할 때 사용한다)

### Rehashing
- 이미 저장되어 있는 요소들의 hashcode를 새로 계산해서 hash 자료구조 사이즈를 늘리고, 새로운 해시 값에 기반해서 새로운 버킷으로 요소를 옮기는 과정
#### 왜 Rehashing을 하는 것일까?
- 높은 threshold 로 인해 발생하는 해시 충돌을 막고, hash 자료구조의 효율적인 탐색을 유지하려고 rehashing을 진행한다

### Marker Interface
- Metadata를 나타내기 위해서 사용한다
- 컴파일러에게 특정한 정보를 제공하려는 목적으로 사용한다
