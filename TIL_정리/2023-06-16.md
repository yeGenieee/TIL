# 2023-06-16

### 📌 학습 계획
- 스프링 입문을 위한 자바 객체 지향의 원리와 이해 Ch01
### ✏️ TIL
- 프로그래밍 언어의 역사
- 기계어
- 어셈블리
- C
- C++ 
- 자바


## 기계어에서 객체 지향 프로그래밍 언어로
### 기계어  : 0과 1의 행진
- 기계가 이해하는 유일한 언어
- 2진 숫자인 0과 1로만 표현된다
- CPU에 따라 기계어 코드가 다르다
	- ex) EDSAC과 UNIVAC의 기계어는 서로 호환되지 않는다


### 어셈블리어 : 0과 1의 행진을 벗어나 인간 지향으로 / 기계어 니모닉
- 기계어는 컴퓨터가 이해하는유일한 언어이지만, 인간이 이해할 수 있는 언어는 아니다
- 🤔 기계어의 명령들을 일상 용어로 표현하고 이것을 기계가 알 수 있는 기계어로 번역하게 하면 좋지 않을까?
- 라는 생각에서 출발하여 
- 기계어 명령어 - 일상 용어를 1:1로 매핑하는 코드표를 만들었다
- 어셈블리 : Mnemonic과 기계어의 일대일 매칭 코드표
- 그러나, CPU마다 기계어가 다르기 때문에 CPU 별로 각자의 어셈블리어(Assembly Language)도 달랐다
- Assembler : 어셈블리어를 기계어로 번역해주는 소프트웨어
- **기계어를 벗어나 인간의 언어를 모방하여 프로그램을 작성할 수 있어졌다**

### C 언어 : 강력한 이식성 / One Source Multi Object Use Anywhere
- 어셈블리어는 CPU 종류마다 (기계마다) 소스파일을 만들었어야 했는데 (Multi Source), C언어의 경우 하나의 소스 파일만 작성하더라도, 이 소스 파일을 각 기계에 맞는 컴파일러로 컴파일만 하면 각 기계에 맞는 object 파일이 만들어졌다
- **멀티 소스일 필요 없이, 하나의 소스만 작성해도 기종별로 컴파일만 하면 모든 컴퓨터에서 실행 가능해진다**
- 비록, 소스코드를 컴파일하기 전에, 운영체제에 맞게 소스를 변경하는 작업이 필요하긴 했지만, 어셈블리어를 이용할 때와 비교하면, C언어는 **이식성이 좋다** 는 특징을 가진다 
- 또한, 기계어와 인간이 이해할 수 있는 언어의 매칭이 1:1 에서, `m:n` 매칭이 가능해졌다

### C++ 언어 : 객체지향 프로그래밍 방법론에 새로운 한 획
- C 언어에 객체 지향 개념을 도입한 언어
- 객체 없는 프로그래밍도 가능하다
	- C++의 `main` 함수는 클래스와 별개로 존재할 수 있고, `printf()` 함수는 클래스나 객체와 관계없이 호출할 수 있다

### 자바 : 진정한 객체 지향 언어
- 클래스를 떠나 존재할 수 있는 것은 아무것도 없다
- JVM이 존재하여, `Write Once, Use Anywhere` 을 실천하였다
- 즉, 컴파일러를 기종별로 따로 설치할 필요가 없다
- 자바에서는, 다른 기종의 컴퓨터에서 실행하기 위해 목적 파일인 object 파일만 가져가면 된다

### 언어별 비교
||어셈블리어|C|Java|
|:---|:---|:---|:---|
|목적 파일|어셈블러로 기계어를 생성한다|컴파일러로 해당 운영체제용 기계어를 생성한다|기종이 몇 개든간에 단 하나의 JVM용 기계어를 생성한다|
|기계어 비교|기계어랑 1:1 대응하는 Mnemonic|기계어와 m:n 대응하는 수학적 기호|기계어와 m:n 대응하는 수학적 기호|
|비고|기종별 어셈블러가 필요하다|기종별 컴파일러가 필요하다|단 하나의 컴파일러만 필요하다, 기종별 JRE는 설정이 필요하다|


## Reference
- 김종민, 『스프링 입문을 위한 자바 객체 지향의 원리와 이해』, 위키북스(2015), p.17 ~ p.35
